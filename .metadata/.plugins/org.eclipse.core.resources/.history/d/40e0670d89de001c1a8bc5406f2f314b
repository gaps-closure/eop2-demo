/*
 * Copyright (c) 2021 Peraton Labs Inc  - All Rights Reserved.
 * Proprietary and confidential. Unauthorized copy or use of this file, via
 * any medium or mechanism is strictly prohibited.
 *
 * @author tchen
 *
 * Oct 5, 2021
 */

#include <zephyr.h>
#include <drivers/flash.h>
#include <device.h>
#include <soc.h>
#include <string.h>

#include "nv/nv.h"

#include "BoardZephyr.hpp"
#include "Prover.hpp"
#include "Log.hpp"

Endpoint endpoint;
Config config(PROVER);
BoardZephyr board;

extern "C" {

static int reload(const char * item_name, int size, uint8_t *buf)
{
    memset(buf, 0, size);
    int ret = read_item(item_name, size, buf);
    if (ret != 0) {
    	SD_LOG(LOG_ERR, "cannot read item %d from flash", item_name);
    	return -1;
    }
    return 0;
}

static void reload_endpoint(uint8_t *buf, int size)
{
    if (reload(NV_PROTOCOL, size, buf) != 0)
    	return;
    string prot((char *)buf);
    Protocol protocol = Endpoint::toProtocol(prot);

    if (reload(NV_PORT, size, buf) != 0)
    	return;
    int port = *(int *) buf;

    if (reload(NV_ADDRESS, size, buf) != 0)
    	return;

    SD_LOG(LOG_INFO, "endpoint in flash: %d:%s:%d", protocol, buf, port);
    string address((char *)buf);

    Endpoint *endpoint = config.getComponent().getOutgoing();

    endpoint->setProtocol(protocol);
    endpoint->setAddress(address);
    endpoint->setPort(port);
}

static void reload_flash()
{
    uint8_t buf[32];
    int ret = read_item(NV_MAGIC, 4, buf);
    if (ret != 0 || buf[0] != 0x0a || buf[1] != 0xce) {
    	SD_LOG(LOG_WARNING, "MAGIC not found");
    	return;
    }
    SD_LOG(LOG_INFO, "MAGIC found");

    if (reload(NV_ID, sizeof(buf), buf) == 0) {
    	string newId((char *)buf);
    	config.getComponent().setID(newId);
    }

    reload_endpoint(buf, sizeof(buf));

    if (reload(NV_KEY_DIST, sizeof(buf), buf) == 0) {
        string newKeyDist((char *)buf);
        KeyEncType keyDist = Config::toKeyEncType(newKeyDist);
    	config.setKeyDistMethod(keyDist);
    }

    if (reload(NV_KEY_CHG_INTVL, sizeof(buf), buf) == 0) {
    	config.setKeyChangeInterval(*(uint32_t *)buf);
    }

    if (reload(NV_ENCRYPT, sizeof(buf), buf) == 0) {
    	config.setEncryptionEnabled(*(uint8_t *)buf != 0);
    }

    if (reload(NV_REPORT_INTVL, sizeof(buf), buf) == 0) {
    	config.setReportInterval(*(uint8_t *)buf);
    }

    if (reload(NV_ATTEST, sizeof(buf), buf) == 0) {
    	config.setAttestationEnabled(*(uint8_t *)buf != 0);
    }

    // TODO: ATTEST SQN
    // TODO: AES_KEY
    // TODO: RA_KEY

    if (reload(NV_SEEC, sizeof(buf), buf) == 0) {
    	config.setSeecEnabled(*(uint8_t *)buf != 0);
    }

    if (reload(NV_KEY_ENCRYPTION, sizeof(buf), buf) == 0) {
    	config.setKeyEncryptionEnabled(*(uint8_t *)buf != 0);
    }

    if (reload(NV_SIGNING, sizeof(buf), buf) == 0) {
    	config.setSigningEnabled(*(uint8_t *)buf != 0);
    }

    if (reload(NV_KEY_CHANGE, sizeof(buf), buf) == 0) {
    	config.setKeyChangeEnabled(*(uint8_t *)buf != 0);
    }

    if (reload(NV_PASSPORT_PERIOD, sizeof(buf), buf) == 0) {
    	config.setPassportPeriod(*(uint32_t *)buf);
    }

    if (reload(NV_PAYLOAD_SIZE, sizeof(buf), buf) == 0) {
    	config.setPayloadSize(*(uint32_t *)buf);
    }

    if (reload(NV_PASS_THRU, sizeof(buf), buf) == 0) {
    	config.setPassThru(*(uint8_t *)buf != 0);
    }

    if (reload(NV_NUM_CYCLES, sizeof(buf), buf) == 0) {
    	config.setNumCycles(*(uint32_t *)buf);
    }

    if (reload(NV_ITERATIONS, sizeof(buf), buf) == 0) {
    	config.setIterations(*(uint32_t *)buf);
    }

    if (reload(NV_AUTHENTICATION, sizeof(buf), buf) == 0) {
    	config.setAuthenticationEnabled(*(uint8_t *)buf != 0);
    }
}

void set_lte_ready()
{
    ConfigComponent &proverConfig = config.getComponent();
    // create a default endpoint; will be overriden below in reload_flash().
    proverConfig.setOutgoing(new Endpoint());
    reload_flash();

    printk("\n%s\n", config.toString().c_str());

    Prover prover(config, &board);
    prover.run();
}
}  // extern "C"
